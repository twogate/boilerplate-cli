import * as fs from 'fs'
import { expect  } from 'chai'

import { ReplaceDefinition } from '../../src/replace-definition'

describe('replace-definition dirtree test', () => {
  let rd
  before(async () => {
    rd = new ReplaceDefinition()
    rd.loadYamlDefinition('./test/fixtures/dir-tree/replacement.yml')
    await Promise.all(rd.replace())
  })

  it('should valid template output of d1-template', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/d1-template.c', 'utf8')
    expect(template).to.be.equal(d1template)
  })
  it('should valid template output of d2-template', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/d2-template.c', 'utf8')
    expect(template).to.be.equal(d2template)
  })
  it('should valid template output of d2-template2', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/d2-template2.y', 'utf8')
    expect(template).to.be.equal(d2template2)
  })
  it('should valid template output of d3-template', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/depth3/d3-template.html', 'utf8')
    expect(template).to.be.equal(d3template)
  })
  it('should valid template output of d3-template2', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/depth3/d3-template2.pde', 'utf8')
    expect(template).to.be.equal(d3template2)
  })
  it('should valid template output of d1-move', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/d1-move-only.txt', 'utf8')
    expect(template).to.be.equal(d1move)
  })
  it('should valid template output of d1-move2', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/d1-move-only2.txt', 'utf8')
    expect(template).to.be.equal(d1move2)
  })
  it('should valid template output of d2-move', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/d2-move-only.txt', 'utf8')
    expect(template).to.be.equal(d2move)
  })
  it('should valid template output of d2-move2', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/d2-move-only2.txt', 'utf8')
    expect(template).to.be.equal(d2move2)
  })
  it('should valid template output of d3-move', async () => {
    const template = fs.readFileSync('./test/tmp/depth1/depth2/depth3/d3-move-only.txt', 'utf8')
    expect(template).to.be.equal(d3move)
  })
})

const d1move = "d1 move 1\n\n##ShouldNotBeReplaced##\n"
const d1move2 = "d1 move 2\n\n\n##ShouldNotBeReplaced##\n\n"
const d2move = "##ShouldNotBeReplaced##\n\nd2 move only\n"
const d2move2 = "##ShouldNotBeReplaced##\n\nd2 move only2\n"
const d3move = "##d3 move##\n\n\n"

const d1template = "/* https://github.com/keiya/brainfuck */\n#include <stdio.h>\n#include <stdlib.h>\n\nchar *prog;\nint ary[30000];\nint *ptr = ary;\nint idx;\n\nint stack[100];\nint stack_flag[100];\nint stack_idx = 0;\n\nvoid\ninit()\n{\n    int i;\n    for (i=0;i<100;i++) {\n        stack[i] = 0;\n        stack_flag[i] = 0;\n    }\n}\n\nvoid\npush(int val,int flag)\n{\n    if (stack_idx < 100) {\n        stack[stack_idx++] = val;\n        stack_flag[stack_idx] = flag;\n    }\n    else {\n        fprintf(stderr,\"stack overflow\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint\npop()\n{\n    if (stack_idx > 0) {\n        int tmp = stack[--stack_idx];\n        return tmp;\n    }\n    else {\n        fprintf(stderr,\"stack underflow\");\n        exit(EXIT_FAILURE);\n    }\n}\n\nint\ncheck()\n{\n    int i;\n    return stack_flag[stack_idx];\n}\n\nint\nread()\n{\n    if (prog[idx] == \'\\0\')\n        return EOF;\n    return prog[idx];\n}\n\nint\ninterpret(int startidx)\n{\n    //printf(\"SI: %d\\n\",startidx);\n    int ch = read();\n    //printf(\"%d\\n\",check());\n    switch (ch) {\n        case \'>\':\n            idx++;\n            if (check()) break;\n            ptr++;\n            break;\n        case \'<\':\n            idx++;\n            if (check()) break;\n            ptr--;\n            break;\n        case \'+\':\n            idx++;\n            if (check()) break;\n            (*ptr)++;\n            break;\n        case \'-\':\n            idx++;\n            if (check()) break;\n            (*ptr)--;\n            break;\n        case \'.\':\n            idx++;\n            if (check()) break;\n            putchar(*ptr);\n            fflush(stdout);\n            break;\n        case \',\':\n            idx++;\n            if (check()) break;\n            *ptr = getchar();\n            break;\n        case \'[\':\n            if (*ptr == 0) {\n                push(idx,1);\n                idx++;\n            }\n            else {\n                push(idx,0);\n                idx++;\n            }\n            break;\n        case \']\':\n            if (check() != 1) {\n                idx = pop();\n            }\n            else {\n                pop();\n                idx++;\n            }\n            break;\n        case EOF:\n            return 0;\n        default:\n            idx++;\n            break;\n            //exit(0);\n    }\n    return 1;\n}\n\nint\nmain(int argc, char *argv[])\n{\n\n    init();\n\n    FILE *fp;\n    if (argc != 2)\n        exit(EXIT_FAILURE);\n    if ((fp = fopen(argv[1],\"r\")) == NULL) {\n        fprintf(stdout,\"file\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    fseek(fp, 0L, SEEK_END);\n    int sz = ftell(fp);\n    fseek(fp, 0L, SEEK_SET);\n\n    if (NULL == (prog = (char *)malloc(sz))) {\n        fprintf(stdout,\"malloc\\n\");\n        exit(EXIT_FAILURE);\n    }\n\n    char dbg;\n    while((*prog = fgetc(fp)) != EOF) {\n        *prog++;\n    }\n    *prog = \'\\0\';\n    fclose(fp);\n\n    prog = prog - sz;\n\n    int i;\n    for (i=0; i<30000; i++)\n        ary[i] = 0;\n\n    fflush(stdin);\n\n    idx = 0;\n    while(interpret(0)) {\n\n    }\n}\n"

const d2template = "/* https://github.com/keiya/paranoid-copy */\n/*\n * cp.c\n * A robust copy command\n * Keiya Chinen <s1011420@coins.tsukuba.ac.jp>\n * */\n\n#include <stdio.h>\n#include <openssl/sha.h>\n#include <getopt.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <string.h>\n#include <limits.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/mman.h>\n#include <libgen.h>\n#include <errno.h>\n#include \"crc32c.c\"\n\n#define MAX(x, y) (((x) > (y)) ? (x) : (y))\n#define MIN(x, y) (((x) < (y)) ? (x) : (y))\n#define OPEN_SRC 0\n#define OPEN_DST 1\n#define SIZE (262144*3)\n#define CHUNK SIZE\n\nstruct file_s {\n\tint isdir;\n\tchar *path;\n};\n\nstruct option_s {\n\tint paranoid;\n\tint recursive;\n};\nstruct option_s option;\n\nvoid error_exit(int er)\n{\n\tperror(\"error\");\n\texit(er);\n}\n\nvoid show_usage()\n{\n\tprintf(\"RTFM!!!!!!!!!!! read the f___ing manual!!!!!!!\\n\");\n\texit(EXIT_FAILURE);\n}\n\nint file_open(char *filename, struct stat *fs, int is_dst)\n{\n\tint fd;\n\tfd = open(filename,\n\t\t\t//writable ? O_CREAT|O_TRUNC|S_IWRITE : O_RDONLY,\n\t\t\tis_dst ? O_CREAT|O_TRUNC|O_RDWR : O_RDONLY,\n\t\t\tis_dst ? S_IRUSR|S_IWUSR : 0);\n\tif (fd < 0) {\n\t\tperror(filename);\n\t\texit(-1);\n\t}\n\n\tif (fstat(fd, fs) < 0) {\n\t\tperror(\"fstat\");\n\t\texit(-1);\n\t}\n\treturn fd;\n}\n\nuint32_t file_crc32c(int fd, size_t fs, void *map)\n{\n\tsize_t off, n;\n\tuint32_t crc=0;\n\tint flag_map_addr_given = 1;\n\tif (map == NULL)\n\t{\n\t\tmap = mmap(NULL, fs, PROT_READ, MAP_SHARED, fd, 0);\n\t\tflag_map_addr_given = 0;\n\t\tif (map == MAP_FAILED) {\n\t\t\tperror(\"mmap crc\");\n\t\t\texit(-1);\n\t\t}\n\t}\n\tlong long remain_size = fs;\n\tfor (off=0;remain_size>0; remain_size -= CHUNK)\n\t{\n\t\tn = CHUNK;\n\t\tif (remain_size < CHUNK)\n\t\t\tn = remain_size;\n//\t\tprintf(\"remain_size=%d mdst=%p off=%d n=%d\\n\",remain_size,mdst,off,n);\n\t\tcrc = crc32c(crc,map + off,n);\n\t\toff += n;\n\t}\n\tif (flag_map_addr_given == 0)\n\t\tmunmap(map,fs);\n\treturn crc;\n}\n\nint do_copy(struct file_s *src, struct file_s *dst)\n{\n\tint crc_match = 0;\n\tint fdsrc, fddst;\n\tstruct stat fssrc,fsdst;\n\tchar *msrc, *mdst;\n\tif (src == NULL||dst == NULL) return;\n#ifdef DEBUG\n\tprintf(\"\'%s\'(%d)->\'%s\'(%d)\\n\",src->path,src->isdir,dst->path,dst->isdir);\n#endif\n\tfdsrc = file_open(src->path, \&fssrc, OPEN_SRC);\n\tfddst = file_open(dst->path, \&fsdst, OPEN_DST);\n\n\tmsrc = mmap(NULL, fssrc.st_size, PROT_READ, MAP_SHARED, fdsrc, 0);\n\tif (msrc == MAP_FAILED) {\n\t\tperror(\"mmap src\");\n\t\texit(-1);\n\t}\n\tif (ftruncate(fddst,fssrc.st_size) != 0)\n\t{\n\t\tperror(\"ftruncate\");\n\t}\n\tmdst = mmap(NULL, fssrc.st_size, PROT_WRITE, MAP_SHARED, fddst, 0);\n\tif (mdst == MAP_FAILED) {\n\t\tperror(\"mmap dst\");\n\t\texit(-1);\n\t}\n\n\tlong long remain_size = fssrc.st_size;\n\n\tchar *tmp_msrc, *tmp_mdst;\n\ttmp_msrc = msrc;\n\ttmp_mdst = mdst;\n\twhile (remain_size--)\n\t{\n\t\t*tmp_mdst++ = *tmp_msrc++;\n\t}\n\n\t// destroy the data if ERRORTEST defined\n\t// for test a crc\n#ifdef ERRORTEST\n\tmdst[0] = ~mdst[0];\n#endif\n\n\tif (msync(mdst,fssrc.st_size,MS_SYNC) != 0)\n\t{\n\t\tperror(\"msync\");\n\t\texit(-1);\n\t}\n\t\n\tmunmap(mdst, fssrc.st_size);\n\n\tif (option.paranoid)\n\t{\n\t\tuint32_t src_crc = file_crc32c(fdsrc,fssrc.st_size,msrc);\n\t\tuint32_t dst_crc = file_crc32c(fddst,fssrc.st_size,NULL);\n\t\tif (src_crc == dst_crc)\n\t\t\tcrc_match = 1;\n\t\telse\n\t\t\tcrc_match = -1;\n\t}\n\n\tmunmap(msrc, fssrc.st_size);\n\tclose(fdsrc);\n\tclose(fddst);\n\treturn crc_match;\n}\n\nint main(int argc, char *argv[])\n{\n\t// allows multiple src\n\t//char **src_path;\n\t//char *dst_path;\n\tstruct file_s **src;\n\tstruct file_s *dst;\n\tint nsrc=0;\n\n\tint ch;\n\tint i;\n\n\n\tstatic struct option long_options[] = {\n\t\t{\"paranoid\", 1, 0, \'c\'},\n\t\t{NULL, 0 , NULL, 0}\n\t};\n\n\toption.paranoid = 0;\n\toption.recursive = 0;\n\twhile ((ch = getopt_long(argc, argv, \"c\", long_options, NULL)) != -1)\n\t{\n\t\tswitch (ch) {\n\t\t\t// paranoid copy mode\n\t\t\t// compare original and copied file by using sha-512\n\t\t\tcase \'c\':\n\t\t\t\toption.paranoid = 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tshow_usage();\n\t\t}\n\t}\n\n\tstruct stat stat_buf;\n\tif (argc-optind >= 2)\n\t{\n\t\tnsrc = argc-optind-1;\n\t\tsrc = malloc(sizeof(struct file_s*) * argc-optind-1);\n\t\tif (src == NULL) error_exit(-ENOMEM);\n\t\tfor (i=optind; i<argc; ++i)\n\t\t{\n\t\t\tint size_path = MIN(strlen(argv[i]),PATH_MAX);\n\t\t\tif (i==argc-1)\n\t\t\t{\n\t\t\t\tdst = malloc(sizeof(struct file_s));\n\t\t\t\tif (dst == NULL) error_exit(-ENOMEM);\n\t\t\t\tdst->path = malloc(size_path);\n\t\t\t\tif (dst->path == NULL) error_exit(-ENOMEM);\n\t\t\t\tif (stat(argv[i],\&stat_buf) == 0)\n\t\t\t\t{\n\t\t\t\t\n\t\t\t\t\tif (S_ISDIR(stat_buf.st_mode))\n\t\t\t\t\t{\n\t\t\t\t\t\tdst->isdir = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t// コピー元が複数にもかかわらず、コピー先がディレクトリでない場合はエラー\n\t\t\t\t\t\tif (nsrc >= 2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tperror(\"target is not a directory.\");\n\t\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t//dst = malloc(size_dst);\n\t\t\t\t\tstrncpy(dst->path,argv[i],size_path);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// コピー元が複数にもかかわらず、コピー先ディレクトリがない場合はエラー\n\t\t\t\t\tif (nsrc >= 2)\n\t\t\t\t\t{\n\t\t\t\t\t\tperror(argv[i]);\n\t\t\t\t\t\texit(EXIT_FAILURE);\n\t\t\t\t\t}\n\t\t\t\t\t// コピー元がひとつの場合、コピー先がなければ新規作成となるのでエラーにはしない\n\t\t\t\t\tstrncpy(dst->path,argv[i],size_path);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (stat(argv[i],\&stat_buf) == 0)\n\t\t\t\t{\n\t\t\t\t\tint idx = i-optind;\n\t\t\t\t\tsrc[idx] = malloc(sizeof(struct file_s));\n\t\t\t\t\tif (src[idx] == NULL) error_exit(-ENOMEM);\n\t\t\t\t\tif (S_ISDIR(stat_buf.st_mode))\n\t\t\t\t\t{\n\t\t\t\t\t\tif (option.recursive == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfprintf(stderr,\"ommiting directory: %s\\n\",argv[i]);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsrc[idx]->isdir = 1;\n\t\t\t\t\t}\n\t\t\t\t\t//src_path[idx] = malloc(size_dst);\n\n\t\t\t\t\tsrc[idx]->path = malloc(size_path);\n\t\t\t\t\tif (src[idx]->path == NULL) error_exit(-ENOMEM);\n\t\t\t\t\tstrncpy(src[idx]->path,argv[i],size_path);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tshow_usage();\n\t}\n\n\t// dstがファイルかつsrcが複数でないとき\n\tif (nsrc == 1)\n\t{\n#ifdef DEBUG\n\t\tprintf(\"src is single file\\n\");\n#endif\n\t\tif (do_copy(src[0],dst) == -1)\n\t\t{\n\t\t\tfprintf(stderr,\"\'%s\'->\'%s\' CRC doesn\'t match\\n\",src[0]->path,dst->path);\n\t\t}\n\t}\n\telse {\n\t\tfor (i=0; i<nsrc; ++i)\n\t\t{\n\t\t\t// dstがディレクトリなら、dst_filename=dst_dir/basename(src_path)\n\t\t\tif (dst->isdir == 1)\n\t\t\t{\n#ifdef DEBUG\n\t\t\t\tprintf(\"dst is directory %s\\n\",dst->path);\n#endif\n\t\t\t\t//char *dirc,  *dname;\n\t\t\t\tchar *basec, *bname;\n\t\t\t\t//char *tmp;\n\t\t\t\t//dirc = strdup(src[i]->path);\n\t\t\t\tbasec = strdup(src[i]->path);\n\t\t\t\t//dname = dirname(dirc);\n\t\t\t\tbname = basename(basec);\n\t\t\t\tint dst_filename_size = MIN(strlen(dst->path)+1+strlen(bname)+1,PATH_MAX);\n\n\t\t\t\t// copy struct files*\n\t\t\t\tstruct file_s *dsttmp;\n\t\t\t\tdsttmp = malloc(sizeof(struct file_s));\n\t\t\t\tif (dsttmp == NULL) error_exit(-ENOMEM);\n\t\t\t\tchar dst_filename[PATH_MAX+1];\n\t\t\t\tdsttmp->path = dst_filename;\n\t\t\t\tstrncpy(dsttmp->path,dst->path,PATH_MAX);\n\t\t\t\tdsttmp->isdir = dst->isdir;\n\n\t\t\t\tchar *pathdup = strdup(dsttmp->path);\n\t\t\t\tsnprintf(dsttmp->path,dst_filename_size,\"%s/%s\",pathdup,bname);\n\t\t\t\tchar dst_realpath[PATH_MAX+1];\n\t\t\t\trealpath(dsttmp->path,dst_realpath);\n\t\t\t\tdsttmp->path = dst_realpath;\n\t\t\t\tfree(pathdup); // strdup\n\t\t\t\tfree(basec); // strdup\n\t\n\t\t\t\tif (do_copy(src[i],dsttmp) == -1)\n\t\t\t\t{\n\t\t\t\t\tfprintf(stderr,\"\'%s\'->\'%s\' CRC doesn\'t match\\n\",src[i]->path,dsttmp->path);\n\t\t\t\t}\n\t\t\t\t//free(tmp); // realloc\n\t\t\t\tfree(dsttmp); // realloc\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n"

const d2template2 = "/* https://github.com/keiya/rubbish */\n%{\n#include <stdio.h>\n#include \"semantic.h\"\n%}\n\n%union {\nELEMENT *element;\nCOMMAND *command;\nREDIRECT *redirect;\n}\n\n%token CND_AND CND_OR STDOUT_APPEND PIPE_STDERR\n\n%type <command> start operations operation pipeline command simple_command\n%type <element> simple_command_element\n%type <redirect> redirection redirection_list\n%token <element> WORD\n\n%start start\n\n%left \'\&\' \';\' \'\\n\' yacc_EOF\n%left CND_AND CND_OR\n%right \'|\' PIPE_STDERR\n%%\nstart:\n\t\toperations operation_terminator\n\t\t{\n\t\t\tparsed_semantic = $1;\n\t\t\tYYACCEPT;\n\t\t}\n\t|\t\'\\n\'\n\t\t{\n\t\t\tYYACCEPT;\n\t\t}\n\t|\tyacc_EOF\n\t\t{\n\t\t\tYYACCEPT;\n\t\t}\n\t;\n\nnewlines:\n\t\t/* empty */\n\t|\t\'\\n\'\n\t;\n\noperations:\n\t\toperation\n\t|\toperation \'\&\'\n\t|\toperation \';\'\n\t;\n\noperation:\n\t\toperation CND_AND newlines operation\n\t|\toperation CND_OR newlines operation\n\t|\toperation \'\&\' operation\n\t|\toperation \';\' operation\n\t|\tpipeline\n\t;\n\nredirection:\n\t\t\'>\' WORD\n\t\t\t{\n\t\t\t\t$$ = redirection($2,REDIR_STDOUT,0);\n\t\t\t}\n\t|\t\'<\' WORD\n\t\t\t{\n\t\t\t\t$$ = redirection($2,REDIR_STDIN,0);\n\t\t\t}\n\t|\tSTDOUT_APPEND WORD\n\t\t\t{\n\t\t\t\t$$ = redirection($2,REDIR_STDOUT,1);\n\t\t\t}\n\nredirection_list:\n\t\tredirection\n\t\t{\n\t\t\t//$$ = $1\n\t\t}\n\t|\tredirection_list redirection\n\t\t{\n\t\t\t// TODO: add $2 to $1(list)\n\t\t}\n\t;\n\nsimple_command_element:\n\t\tWORD\n\t\t{\n\t\t\t$$ = $1;\n\t\t}\n\t|\tredirection\n\t\t{\n\t\t\t$$ = redirect_element($1);\n\t\t}\n\t;\n\nsimple_command:\n\t\tsimple_command_element\n\t\t\t{\n\t\t\t\t$$ = element_command($1,NULL);\n\t\t\t}\n\t|\tsimple_command simple_command_element\n\t\t\t{\n\t\t\t\t$$ = element_command($2,$1);\n\t\t\t}\n\t;\n\ncommand:\n\t\tsimple_command\n\t;\n\npipeline:\n\t\tpipeline \'|\' newlines pipeline\n\t\t{ $$ = create_pipeline($1,$4); }\n\t|\tpipeline PIPE_STDERR newlines pipeline\n\t|\tcommand\n\t;\n\noperation_terminator:\n\t\t\'\\n\'\n\t|\tyacc_EOF\n\t;\n\n%%\n\n#include \"lexer.c\""

const d3template = "<!-- https://github.com/keiya/music-theory -->\n<html>\n<head>\n<meta charset=\"utf-8\">\n<script src=\"mootools-core-1.4.5-full-nocompat-yc.js\"></script>\n<script src=\"Audiolet/src/audiolet/Audiolet.min.js\"></script>\n<script src=\"audiolet_app.js\"></script>\n<script src=\"music.js/music.js\"></script>\n<script src=\"easeljs-0.7.1.min.js\"></script>\n<script src=\"cf.js\"></script>\n</head>\n<body onLoad=\"init();\">\n<h1>Playable Circle of Fifths</h1>\n<p lang=\"en\"><strong>Click to play</strong> the chord. Powered by Web Audio API \&amp; Canvas</p>\n    <canvas id=\"demoCanvas\" width=\"620\" height=\"620\">\nuse a Canvas-supported browser\n    </canvas>\n<p lang=\"ja\">音が鳴る五度圏です。クリックで再生できます。Web Audio APIとCanvasを利用しています。</p>\n</body>\n</html>\n"

const d3template2 = "// https://github.com/keiya/car-control-simulator/blob/master/car.pde\nCar c;\nControl ct;\n  \nvoid setup(){\n  \n  frameRate(60);\n  size(1280, 720);\n  \n  background(255);\n  c = new Car(300,200,0,0,0,0,0,0);\n  \n  // controller\n  ct = new Control(0, 0, 0);\n}\n\nvoid draw(){\n  background(255);\nnoFill();\nstroke(0, 0, 255);\n//ellipse(300, 200, 180, 180);\ndouble[] controls = ct.getControlValues();\nc.update(controls[0], controls[1], controls[2]);\nc.draw();\n  if ((keyPressed == true) \&\& (key == \'r\')) {\n    c.reset(640,380);\n  }\n}\n\nclass Control {\n  int deadzone = 50;\n  int halfDeadzone = deadzone/2;\n  float halfWidth = width/2;\n  float halfHeight = height/2;\n  double throttle, brake, steering;\n  int xMin, xMax, xCtr, yCtr, yMin, yMax;\n  \n  Control (float _throttle, float _brake, float _steering) {\n    throttle = _throttle;\n    brake = _brake;\n    steering = _steering;\n    xMin = width/2-halfDeadzone;\n    yMin = height/2-halfDeadzone;\n    xCtr = xMin+halfDeadzone;\n    yCtr = yMin+halfDeadzone;\n    xMax = xMin + deadzone;\n    yMax = yMin + deadzone;\n  }\n  \n  double[] getControlValues() {\n    steering = 0.0;\n    throttle = 0.0;\n    brake = 0.0;\n    \n    stroke(0,255,0);\n    rect(xMin, yMin, deadzone, deadzone);\n    if (xMin > mouseX) {\n      line(mouseX, yCtr, xMin, yCtr);\n      steering = (mouseX - xCtr) / halfWidth;\n    } else if (xMax < mouseX) {\n      line(mouseX, yCtr, xMax, yCtr);\n      steering = (mouseX - xCtr) / halfWidth;\n    }\n    if (yMin > mouseY) {\n      line(xCtr, mouseY, xCtr, yMin);\n      throttle = (yCtr - mouseY) / halfHeight;\n    } else if (yMax < mouseY) {\n      line(xCtr, mouseY, xCtr, yMax);\n      brake = (mouseY - yCtr) / halfHeight;\n    }\n\n    double[] array = {steering,throttle,brake};\n    //println(steering,throttle,brake);\n    return array;\n  }\n}\n\nclass Car {\n  final float accelerationFadeout = 0.05;\n\n  float x, y, vx, vy, ax, ay, heading, a, v;\n  double headingRate;\n  float slipAngle;\n  \n  // Lng = Longitudinal direction\n  // Hrz = Horizontal direction (skidding)\n  double vehicleALng, vehicleAHrz, vehicleVLng, vehicleVHrz;\n  double lastVehicleVHrz;\n\n  float throttle, brake, steering;\n  float halfWidth = width/2;\n  \n  Car (float _x, float _y, float _vehicleVLng, float _vehicleVHrz, float _vehicleALng, float _vehicleAHrz, float _heading, float _headingRate) {\n    x = _x;\n    y = _y;\n    vehicleVLng = _vehicleVLng;\n    vehicleVHrz = _vehicleVHrz;\n    lastVehicleVHrz = 0;\n    vehicleALng = _vehicleALng;\n    vehicleAHrz = _vehicleAHrz;\n    calcWorldCoordinate();\n    heading = _heading;\n    headingRate = _headingRate;\n  }\n  \n  void reset(float _x, float _y) {\n    x = _x;\n    y = _y;\n    vehicleVLng = 0;\n    vehicleVHrz = 0;\n    vehicleALng = 0;\n    vehicleAHrz = 0;\n    lastVehicleVHrz = 0;\n    heading = 0;\n    headingRate = 0;\n    ax = 0;\n    ay = 0;\n    vx = 0;\n    vy = 0;\n    calcWorldCoordinate();\n  }\n  \n  void calcWorldCoordinate() {\n    ax = cos((float)heading)*(float)vehicleAHrz + sin((float)heading)*(float)vehicleALng;\n    ay = sin((float)heading)*(float)vehicleAHrz - cos((float)heading)*(float)vehicleALng;\n\n    float dx = 0; //sin((float)heading)*(float)vehicleVLng;\n    float dy = 0; //-cos((float)heading)*(float)vehicleVLng;\n\n    vx += ax;\n    vy += ay;\n    x += vx + dx;\n    y += vy + dy;\n    a = sqrt(pow(ax,2) + pow(ay,2));\n    v = sqrt(pow(vx,2) + pow(vy,2));\n  }\n  \n  void update(double steering, double throttle, double brake) {\n    headingRate = steering * 0.01;\n    heading = (heading + (float)headingRate)%TWO_PI;\n    \n    //vehicleAHrz = vehicleVLng * steering;\n    //println(vehicleAHrz);\n    //vehicleVHrz = vehicleVHrz + vehicleAHrz;\n\n    vehicleALng = - (vehicleALng * abs((float)steering));\n    vehicleALng = throttle * 0.01 - min(abs((float)vehicleVLng), accelerationFadeout) * brake * 0.2;\n    vehicleVLng = vehicleVLng + vehicleALng;\n\n    // nx, ny = normalized vector\n    v = sqrt(pow(vx,2) + pow(vy,2));\n    float nx = vx / v;\n    float ny = vy / v;\n    nx = Float.isNaN(nx) ? 0 : nx;\n    ny = Float.isNaN(ny) ? 0 : ny;\n\n    pushMatrix();\n    translate(x,y);\n    float vectorHdg = (atan2(ny * height,nx * width) + HALF_PI)%TWO_PI;\n    popMatrix();\n\n    slipAngle = vectorHdg - heading;\n    vehicleVHrz = v * sin(slipAngle);\n\n    //calcLongitudinalDrag();\n    //calcHorizontalDrag();\n\n    calcWorldCoordinate();\n  }\n\n  void calcLongitudinalDrag() {\n    double decelerationLng = 0;\n    float carGoingTo = 0;\n    if (vehicleVLng > accelerationFadeout) {\n      carGoingTo = 1;\n    } else if (vehicleVLng < -accelerationFadeout) {\n      carGoingTo = -1;\n    }\n    decelerationLng = pow((float)vehicleVLng,2) * 0.01 // drag\n                    + 0.001; // (Rolling resistance + engine braking) while no gas pedal, no brake\n    vehicleALng -= (decelerationLng * carGoingTo);\n        println(carGoingTo, (decelerationLng * carGoingTo));\n  }\n\n  void calcHorizontalDrag() {\n    if (slipAngle > 0 || slipAngle < 0) {\n      // car can\'t move horizontally.\n      // friction applys to horizontal movement\n      vehicleAHrz = -(vehicleVHrz - lastVehicleVHrz)/2;\n    } else {\n      vehicleAHrz = 0;\n    }\n    println(vehicleAHrz,slipAngle);\n    lastVehicleVHrz = vehicleVHrz;\n  }\n  \n  void draw() {\n    pushMatrix();\n    translate(x, y);\n    rotate(heading);\n    stroke(0, 0, 0);\n    triangle(10, 0, 5, 25, 15, 25);\n    popMatrix();\n\n    stroke(255,0,0);\n    line(x, y, x+ax*5000, y+ay*5000);\n\n    stroke(0,0,255);\n    line(x, y, x+vx*100, y+vy*100);\n   \n    textAlign(LEFT);\n    text(\"aL\", halfWidth-100, height-15); // vehicle longitudinal acceleration\n    text(\"aH\", halfWidth-100, height-5); // vehicle horizontal acceleration\n    text(\"vL\", halfWidth-40, height-15); // vehicle longitudinal velocity\n    text(\"vH\", halfWidth-40, height-5); // vehicle horizontal velocity\n    text(\"HDG\", halfWidth+20, height-15); // vehicle heading\n    text(\"HDGRate\", halfWidth+20, height-5); // vehicle heading turn rate\n\n\n    textAlign(RIGHT);\n    text((float)vehicleALng, halfWidth-45, height-15);\n    text((float)vehicleAHrz, halfWidth-45, height-5);\n    text((float)vehicleVLng, halfWidth+15, height-15);\n    text((float)vehicleVHrz, halfWidth+15, height-5);\n    text(heading, halfWidth+110, height-15);\n    text((float)headingRate, halfWidth+110, height-5);\n    \n    text(a, halfWidth-15, height-30);\n    text(v, halfWidth+25, height-30);\n  }\n}"